package ch25_channer_context

// make(chan int) 이렇게 생성하면 2번 go파일에서 본 것처럼 채널에서 데이터를 가져가기를 대기하다가 데드락이 발생했다.
// 즉 데이터를 채널에 보관해둘 수 없었기 때문인데, 버퍼의 크기를 채널에 부여해서 일정 개수의 데이터는 채널에 존재해도 문제를 일으키지 않게
// 할 수 있다.

// 예시 : var myChan chan string = make(chan string, 2) -> 버퍼가 2개인 채널 생성.

// 만약 버퍼가 다 차면 버퍼가 없을 때와 마찬가지로 버퍼에 남는 자리가 생길때까지 대기한다.
// 그래서 데이터를 버퍼에서 제때 빼가지 않으면 버퍼가 없을 때처럼(size=0) 고루틴이 멈추게 된다.

// 25.1.6. 채널에서 데이터 대기
// 1번 go파일에서는 채널에 데이터를 하나 넣고 빼보았다.
// 이번에는 고루틴에서 데이터를 계속 기다리면서 데이터가 들어오면 작업을 수행하는 예제를 구현해본다.

import (
	"fmt"
	"sync"
	"time"
)

func square2(wg *sync.WaitGroup, ch chan int) {
	for n := range ch { // 2. 데이터를 계속 기다림.
		// ch 채널 인스턴스로부터 데이터가 들어오기를 기다렸다가 들어오면 데이터를 빼서 변수 n에 복사하고 for문실행.
		fmt.Printf("Square: %d\n", n*n)
		time.Sleep(time.Second)
	}
	wg.Done() // 4. 실행되지 않음.
	// for range 구문은 채널에 데이터가 들어오기를 계속 기다리기 때문에, 절대 wg.Done이 실행되지 않고, ch에 더이상 데이터가 들어오지 않게
	// 되면 데드락이 된다.

	// 그럼 어떻게 문제를 해결할 수 있을 까?
	// 채널을 다 사용하면 close(ch)를 호출해 채널을 닫고 채널이 닫혔음을 알려줘야 한다.
	// 채널에서 데이터를 모두 빼낸 상태이고, 채널이 닫혔으면 for range 문을 빠져나가야 한다.
}

func WaitDataFromChannel() {
	var wg sync.WaitGroup
	ch := make(chan int)

	wg.Add(1)
	go square2(&wg, ch)

	for i := 0; i < 10; i++ {
		ch <- i * 2 // 1. 데이터를 넣어줌.
	}
	close(ch)
	// --> 5. 이걸 꼭 해줘야 채널을 닫아주게 되는 것이고, square2에서도 채널이 닫힌 상태인지 체크하기 때문에 for문을 종료해서
	// wg.Done을 호출해줄 수 있게되어 프로그램이 정상 종료된다.

	wg.Wait() // 3. 작업 완료를 기다림.
}

// 이렇게 채널을 제때 닫아주지 않아서 고루틴에서 데이터를 기다리며 무한 대기하는 경우를 '좀비 루틴' 또는 '고루틴 릭'이라고 한다.
// 아무리 경량 스레드라고 해도 고루틴도 메모리와 성능을 차지하기 때문에 이런 좀비 루틴이 많아지면 프로그램 자원을 소모하게 되고,
// 프로그램이 느려지거나 메모리 부족으로 강제 종료될 수 있다.
