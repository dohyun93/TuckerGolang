package ch24_goroutine

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func SubGoRoutine() {
	wg.Add(10) // 완료되어야 하는 작업의 수를 설정한다.
	for i := 0; i < 10; i++ {
		go addAtoB(1, 100000000)
	}
	wg.Wait() // 모든 sub go routine들이 종료되길 기다린다.
}

func addAtoB(a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += i
	}
	fmt.Printf("%d부터 %d까지의 합은 %d 입니다.\n", a, b, sum)
	wg.Done() // 각 작업이 완료될 때 마다 남은 작업의 개수를 줄여준다.
}

// 고루틴은 명령을 수행하는 단일 흐름으로, OS 스레드를 이용하는 경량 스레드 이다.
// 이 말이 무슨 뜻인지, OS 스레드와 고루틴은 무엇이 다른지 알아보자.

// Go 언어에서는 CPU 코어/OS 스레드/고루틴을 서로 조율하여 사용해 고루틴을 효율적으로 다룬다.
// 고루틴과 스레드 간의 관계를 알아보기 위해서 2개의 코어를 가진 컴퓨터에서 고루틴이 동작하는 원리를 알아보자.
// 첨부 사진 참고.
// Go 루틴은 아래와 같은 이유때문에 우수한 성능을 자랑한다.

// 시스템 콜이란? : OS가 제공하는 서비스를 호출하는 것을 말하며, 대표적으로 이 OS가 제공하는 서비스로는 네트워크 기능이 있다.)
// 코어마다 OS 스레드 하나를 할당하고, Go 루틴을 각 코어의 OS 스레드마다 최대 하나씩 할당하여 동작한다.
// 코어에서 실행하는 스레드가 변경될 때 스레드 컨텍스트 저장/복원과 컨텍스트 스위칭이 발생하는데, OS 스레드는 변하지 않고
// 오직 처리되는 고루틴만 변경되기 때문에 컨텍스트 스위칭 비용이 발생하지 않는다.
// 따라서 수 백, 수 천 스레드를 마음껏 만들어서 사용할 수 있다.
